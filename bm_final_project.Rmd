---
title: "bm_final_project"
author: "Yun He"
date: "December 6, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(glmnet)
library(HH)
library(leaps)
```

## Data cleaning 

```{r}
cancer = read_csv("./Cancer_Registry.csv") %>% 
  janitor::clean_names() %>% 
  separate(geography, into = c("county", "state"), sep = ",")

## demographic: age, race, marital status, income, education, employment and health insurance coverage

ses_cor = cancer %>% 
  dplyr::select(med_income, poverty_percent, pct_unemployed16_over, pct_private_coverage, pct_emp_priv_coverage, pct_public_coverage, pct_public_coverage_alone)
library(ggcorrplot)
corr = round(cor(ses_cor), 1)
ggcorrplot(corr, hc.order = TRUE, type = "lower", lab = TRUE)
## income, employment status and health insurance coverage are highly correlated
cancer %>% 
  select(target_death_rate, med_income, poverty_percent) %>% 
  ggscatmat() + geom_smooth(method = "lm")
  
income_edu = cancer %>% 
  dplyr::select(target_death_rate, poverty_percent, pct_no_hs18_24, pct_hs18_24, pct_bach_deg18_24, pct_hs25_over, pct_bach_deg25_over)
corr = round(cor(income_edu), 1)
ggcorrplot(corr, hc.order = TRUE, type = "lower", lab = TRUE)
## high correlation between med_income and pct_bach_deg25_over, pct_hs25_over and pct_bach_deg25_over, so choose pct_hs25_over

## Check with missing values
skimr::skim(cancer %>% select(-state, -county))

## Select variables
cancer = cancer %>% 
  dplyr::select(state, county, target_death_rate, incidence_rate, study_per_cap, poverty_percent, median_age_female, percent_married, pct_no_hs18_24, pct_hs18_24, pct_bach_deg18_24, pct_hs25_over, pct_white, pct_asian, pct_other_race)
```

The original dataset has 35 variables and 3047 observations. 

Both employment status and health insurance coverage status can be reflected by income. Thus, we only included income for subsequent analyses. We chose the variable 'binned_inc' from 'med_income', 'poverty_percent' and 'binned_inc' for measuring the income level. We combined some of its levels and divided income into 3 levels which are "low", "medium" and "high". We chose 'percent_married' from 'percent_married' and 'pct_married_households' for measuring the marital status. We chose 'median_age_female' from 'median_age', 'median_age_female' and 'median_age_male' for measuring the age. 'pct_white' and 'pct_black' are highly correlated, thus, we removed 'pct_black'. 'pct_hs25_over' and 'pct_bach_deg25_over' re highly correlated, thus, we removed 'pct_bach_deg25_over'. Finally, we included demographic variables for age, income, race, education and marital status for subsequent analyses which, in previous research, are also found to be correlated with cancer mortality.

'pct_some_col18_24' was removed because of the relatively large amount of missing values. 
We chose 'incidence_rate' from 'avg_ann_count' and 'incidence_rate' for measuring mean cancer diagnoses annually. We also remained the variable 'study_per_cap' for measuring number of cancer-related clinical trials per county. 

In addition, because our outcome is 'target_death_rate' which can be calculated from dividing the variable 'avg_deaths_per_year' by the variable 'pop_est2015', we removed these two variables from our dataset. 'avg_household_size' and 'birth_rate' seem to be uncorrelated with the outcome, thus, we removed them from our dataset as well. 

We ended with the dataset of 15 variables and 3047 observations. 

Marital status is also correlated with cancer mortality. 
https://www.ncbi.nlm.nih.gov/pubmed/29727804

## Data exploration

```{r}
## Distribution of continuous variables
descp_stats = function(x){
  df = broom::tidy(summary(x)) %>% 
    mutate(sd = sd(x))
  return(df)
}

desp_var = cancer %>% 
  dplyr::select(-state, -county, -binned_inc) %>% 
  map_df(descp_stats) %>%
  mutate(minimum = round(minimum, 2),
         q1 = round(q1, 2),
         median = round(median, 2), 
         mean = round(mean, 2),
         q3 = round(q3, 2),
         maximum = round(maximum, 2),
         sd = round(sd, 2),    
         variable = c("target_death_rate", "incidence_rate", "study_per_cap", "median_age_female", "percent_married", "pct_no_hs18_24", "pct_hs18_24", "pct_bach_deg18_24", "pct_hs25_over", "pct_white", "pct_asian", "pct_other_race")) %>% 
  dplyr::select(variable, mean, sd, everything())
write_csv(desp_var, "decp_var.csv")

## Distribution of the death rate
cancer %>%
  ggplot(aes(x = target_death_rate)) + 
  geom_histogram(aes(y = ..density..)) + geom_density(color = "red") +
  labs(x = "Death rate")

## Distribution of categorical variables
cancer %>% 
  ggplot(aes(x = binned_inc, y = target_death_rate)) + geom_boxplot() +
  labs(x = "Income level", 
       y = "Death rate")
```

The outcome 'death rate' is normally distributed.

## Fit the model

### backward elimination

```{r}
cancer_mod = cancer %>% 
  dplyr::select(-state, -county)

fit = lm(target_death_rate ~ ., data = cancer_mod)
summary(fit)

step(fit, direction = "backward")
refit = lm(target_death_rate ~ incidence_rate + poverty_percent + 
    median_age_female + pct_hs18_24 + pct_bach_deg18_24 + pct_hs25_over + 
    pct_white + pct_other_race, data = cancer_mod)
vif(refit) ## check multicollinearity
summary(refit)

## check outliers
### outliers in Y
stu_res = rstandard(refit)
stu_res[abs(stu_res) > 2.5]

### leverage
hat_value = hatvalues(refit)
hat_value[hat_value > 0.2]

### influential points
influence.measures(refit)

plot(refit)

## refit the model without potential outliers
mod_no = cancer_mod %>% slice(-282) %>% slice(-1220) 
refit_no = lm(target_death_rate ~ incidence_rate + binned_inc + 
    median_age_female + percent_married + pct_hs18_24 + pct_bach_deg18_24 + 
    pct_hs25_over + pct_white + pct_other_race, data = cancer_mod)
summary(refit_no)
```

Model assumptions hold true.

### Cp and adj R2 criteria

```{r}
b = regsubsets(target_death_rate ~ ., data = cancer_mod, nvmax = 9)
   (rs = summary(b))

# Plots of Cp and Adj-R2 as functions of parameters
par(mar = c(4,4,1,1))
par(mfrow = c(1,2))
plot(2:10, rs$cp, xlab = "No of parameters", ylab = "Cp Statistic")
abline(0,1)
plot(2:10, rs$adjr2, xlab = "No of parameters", ylab = "Adj R2")

refit_2 = lm(target_death_rate ~ incidence_rate + poverty_percent + pct_hs18_24+ pct_hs25_over, data = cancer_mod)
summary(refit_2)
plot(refit_2)
```

### Lasso regression

```{r}
cancer = cancer %>% 
  dplyr::select(state, county, target_death_rate, incidence_rate, study_per_cap, poverty_percent, median_age_female, percent_married, pct_no_hs18_24, pct_hs18_24, pct_bach_deg18_24, pct_hs25_over, pct_white, pct_asian, pct_other_race)

cancer_mod = cancer %>% 
  dplyr::select(-state, -county)

## no NA
Y <- as.matrix(cancer_mod[,1])
X <- as.matrix(cancer_mod[,-1])
grid <- 10^seq(5,-2, length=100)
ridge3<-glmnet(X, Y, alpha=1, lambda=grid)

set.seed(2)
cv.out<-cv.glmnet(X,Y)
plot(cv.out)
best.lambda<-cv.out$lambda.min
lasso2<-glmnet(X, Y, alpha =1, lambda=best.lambda)
coef(lasso2)

lasso2$dev.ratio
multi_fit = lm(target_death_rate ~ incidence_rate + study_per_cap + med_income + median_age_female + percent_married + pct_no_hs18_24 + pct_hs18_24 + pct_bach_deg18_24 + pct_hs25_over + pct_white + pct_asian + pct_other_race, data = cancer_mod)
res_ls_ridge_lasso<- cbind(coef(multi_fit), coef(lasso2))
colnames(res_ls_ridge_lasso) <- c("LS", "Lasso")
res_ls_ridge_lasso
```

## Cross validation

```{r}
library(caret)

# Use 5-fold validation and create the training sets

data_train<-trainControl(method="cv", number=5)

# Fit the 4-variables model that we discussed in previous lectures
model_caret<-train(target_death_rate ~ incidence_rate + poverty_percent + median_age_female + pct_hs18_24 + pct_bach_deg18_24 + pct_hs25_over + pct_white + pct_other_race, 
                   data = cancer_mod,
                   method='lm',
                   na.action=na.pass)
  
# Model predictions using 4 parts of the data fro training 
model_caret

model_caret_2<-train(target_death_rate ~ incidence_rate + poverty_percent + pct_hs18_24 + pct_hs25_over,
                   data = cancer_mod,
                   method='lm',
                   na.action=na.pass)
  
# Model predictions using 4 parts of the data fro training 
model_caret_2

library(MPV)                           # For PRESS criterion

newsummary <- function(model)
{
    list('coefs'    = round(t(summary(model)$coef[, 1:2]), 4),
         'criteria' = cbind('SSE'   = anova(model)["Residuals", "Sum Sq"],
                            'PRESS' = PRESS(model),
                            'MSE'   = anova(model)["Residuals", "Mean Sq"],
                            'Rsq'   = summary(model)$adj.r.squared))
}

newsummary(refit_2)
newsummary(refit)
```

